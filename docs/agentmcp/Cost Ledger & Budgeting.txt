/*
PACKAGE: sentinel/cost
MODULE 1: FINANCIAL LEDGER & BUDGET ENFORCEMENT
VERSION: 3.0.0-Enterprise

OVERVIEW:
This module transforms Sentinel from a Security Guardrail into a Financial Guardrail.
It acts as a localized "FinOps" platform for AI Agents.

CORE FEATURES:
1. Double-Entry Ledger: Tracks every token spent against a specific Task ID and Sprint ID.
2. Rate Cards: Dynamic pricing models for various LLMs (Claude 3.5, GPT-4o, Gemini 1.5).
3. Budget Enforcement: Hard blocks on Tool Execution if the Daily or Sprint budget is exceeded.
4. Forecasting: Linear regression to predict if the current Sprint will go over budget based on velocity.

DATABASE SCHEMA (Managed by Kernel, defined here for reference):
  CREATE TABLE cost_budgets (
    scope TEXT PRIMARY KEY, -- 'GLOBAL', 'SPRINT-X', 'DAILY'
    limit_usd DECIMAL(10, 4),
    current_usage_usd DECIMAL(10, 4),
    alert_threshold_pct INTEGER -- e.g. 80%
  );

  CREATE TABLE cost_transactions (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    timestamp DATETIME,
    task_id TEXT,
    model_id TEXT,
    input_tokens INTEGER,
    output_tokens INTEGER,
    total_cost_usd DECIMAL(10, 6),
    tool_name TEXT
  );
*/

package cost

import (
	"database/sql"
	"encoding/json"
	"fmt"
	"log"
	"sync"
	"time"
)

// =============================================================================
// DATA STRUCTURES
// =============================================================================

// RateCard defines the pricing for a specific model (USD per 1M tokens).
type RateCard struct {
	ModelID        string
	InputPricePerM float64
	OutputPricePerM float64
}

// DefaultRates provides baseline pricing (updated 2026).
var DefaultRates = map[string]RateCard{
	"claude-3-5-sonnet": {ModelID: "claude-3-5-sonnet", InputPricePerM: 3.00, OutputPricePerM: 15.00},
	"gpt-4o":            {ModelID: "gpt-4o", InputPricePerM: 2.50, OutputPricePerM: 10.00},
	"gemini-1-5-pro":    {ModelID: "gemini-1-5-pro", InputPricePerM: 3.50, OutputPricePerM: 10.50},
	"local-model":       {ModelID: "local-llama", InputPricePerM: 0.00, OutputPricePerM: 0.00},
}

// Budget represents a spending limit.
type Budget struct {
	Scope           string  // e.g., "SPRINT-24"
	Limit           float64 // USD
	Used            float64 // USD
	AlertThreshold  float64 // 0.8 (80%)
	IsHardStop      bool    // If true, block execution on overage
}

// Ledger is the main controller.
type Ledger struct {
	mu           sync.RWMutex
	db           *sql.DB
	ActiveModel  string
	CurrentRates RateCard
}

// NewLedger initializes the financial system.
func NewLedger(db *sql.DB, modelID string) *Ledger {
	rates, ok := DefaultRates[modelID]
	if !ok {
		// Fallback to a mid-tier price if unknown
		rates = DefaultRates["claude-3-5-sonnet"]
	}

	return &Ledger{
		db:           db,
		ActiveModel:  modelID,
		CurrentRates: rates,
	}
}

// =============================================================================
// BUDGET ENFORCEMENT LOGIC
// =============================================================================

// CheckBudget verifies if an estimated cost can be afforded.
// Returns nil if allowed, error if blocked.
func (l *Ledger) CheckBudget(estimatedCost float64, sprintID string) error {
	l.mu.RLock()
	defer l.mu.RUnlock()

	// 1. Check Global Daily Budget
	if err := l.checkScope("DAILY-"+time.Now().Format("2006-01-02"), estimatedCost); err != nil {
		return err
	}

	// 2. Check Sprint Budget
	if sprintID != "" {
		if err := l.checkScope("SPRINT-"+sprintID, estimatedCost); err != nil {
			return err
		}
	}

	return nil
}

func (l *Ledger) checkScope(scope string, cost float64) error {
	var limit, used float64
	var hardStop bool

	// Query DB for budget status
	// We optimize by keeping a cache, but for this implementation we query direct
	err := l.db.QueryRow(
		"SELECT limit_usd, current_usage_usd, is_hard_stop FROM cost_budgets WHERE scope = ?", 
		scope,
	).Scan(&limit, &used, &hardStop)

	if err == sql.ErrNoRows {
		return nil // No budget defined for this scope, allow.
	} else if err != nil {
		return fmt.Errorf("budget check failed: %v", err)
	}

	projected := used + cost
	if projected > limit {
		if hardStop {
			return fmt.Errorf("BUDGET EXCEEDED: Scope %s is at $%.4f/$%.4f. Operation cost $%.4f blocked.", 
				scope, used, limit, cost)
		}
		log.Printf("BUDGET WARNING: Scope %s is over budget ($%.4f/$%.4f).", scope, projected, limit)
	}

	return nil
}

// =============================================================================
// TRANSACTION RECORDING
// =============================================================================

// RecordUsage logs a completed interaction and updates budget accumulators.
func (l *Ledger) RecordUsage(taskID string, inputTok, outputTok int, toolName string) error {
	l.mu.Lock()
	defer l.mu.Unlock()

	// 1. Calculate Cost
	inputCost := (float64(inputTok) / 1_000_000) * l.CurrentRates.InputPricePerM
	outputCost := (float64(outputTok) / 1_000_000) * l.CurrentRates.OutputPricePerM
	totalCost := inputCost + outputCost

	// 2. Insert Transaction
	tx, err := l.db.Begin()
	if err != nil {
		return err
	}

	_, err = tx.Exec(`
		INSERT INTO cost_transactions 
		(timestamp, task_id, model_id, input_tokens, output_tokens, total_cost_usd, tool_name)
		VALUES (?, ?, ?, ?, ?, ?, ?)
	`, time.Now(), taskID, l.ActiveModel, inputTok, outputTok, totalCost, toolName)

	if err != nil {
		tx.Rollback()
		return err
	}

	// 3. Update Budgets (Daily & Sprint)
	// We use an "Upsert" logic here simulated via Update
	sprintID := l.resolveSprintID(taskID) // Helper to get sprint from task
	scopes := []string{
		"DAILY-" + time.Now().Format("2006-01-02"),
		"SPRINT-" + sprintID,
		"GLOBAL",
	}

	for _, scope := range scopes {
		// Increment usage
		_, err := tx.Exec(`
			UPDATE cost_budgets 
			SET current_usage_usd = current_usage_usd + ? 
			WHERE scope = ?
		`, totalCost, scope)
		if err != nil {
			log.Printf("Failed to update budget for %s: %v", scope, err)
			// Don't fail the transaction just for budget sync
		}
	}

	return tx.Commit()
}

// =============================================================================
// REPORTING & FORECASTING
// =============================================================================

type CostReport struct {
	TotalSpend      float64
	MostExpensiveTask string
	AverageCostPerTurn float64
	ProjectedOverage   float64
}

// GenerateSprintReport creates a financial summary.
func (l *Ledger) GenerateSprintReport(sprintID string) (*CostReport, error) {
	rows, err := l.db.Query(`
		SELECT total_cost_usd, task_id 
		FROM cost_transactions 
		WHERE task_id IN (SELECT id FROM tasks WHERE sprint_id = ?)
	`, sprintID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var total float64
	var count int
	taskCosts := make(map[string]float64)

	for rows.Next() {
		var cost float64
		var tid string
		rows.Scan(&cost, &tid)
		total += cost
		taskCosts[tid] += cost
		count++
	}

	// Find most expensive task
	var maxTask string
	var maxCost float64
	for tid, c := range taskCosts {
		if c > maxCost {
			maxCost = c
			maxTask = tid
		}
	}

	return &CostReport{
		TotalSpend:         total,
		MostExpensiveTask:  fmt.Sprintf("%s ($%.4f)", maxTask, maxCost),
		AverageCostPerTurn: total / float64(count),
	}, nil
}

// helper to mock sprint resolution
func (l *Ledger) resolveSprintID(taskID string) string {
	// In real implementation, query 'tasks' table
	return "CURRENT" 
}